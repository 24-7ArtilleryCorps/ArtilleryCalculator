<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>24/7 Conflict Ops - Artillery Elevation Calculator</title>
    <style>
        body {
            font-family: 'Courier New', Courier, monospace;
            margin: 0;
            padding: 20px;
            background-color: #1a1a1a;
            color: #00ff00;
        }

        .container {
            max-width: 800px;
            margin: auto;
            padding: 20px;
            background-color: #333333;
            border: 2px solid #00ff00;
            border-radius: 5px;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.2);
        }

        h1, h2, h3 {
            color: #00ff00;
            text-align: center;
            text-shadow: 0 0 10px #00ff00;
        }

        label {
            font-weight: bold;
            color: #00ff00;
            text-shadow: 0 0 5px #00ff00;
        }

        input[type="number"], select {
            width: 100%;
            padding: 10px;
            margin: 10px 0;
            border-radius: 3px;
            border: 1px solid #00ff00;
            background-color: #000000;
            color: #00ff00;
            font-family: 'Courier New', Courier, monospace;
            box-shadow: inset 0 0 10px rgba(0, 255, 0, 0.2);
        }

        button {
            width: 100%;
            padding: 10px;
            background-color: #00ff00;
            color: #000000;
            border: 2px solid #00ff00;
            border-radius: 3px;
            cursor: pointer;
            font-size: 16px;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
            transition: background-color 0.3s ease;
            font-family: 'Courier New', Courier, monospace;
        }

        button:hover {
            background-color: #00cc00;
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.8);
        }

        .result {
            margin-top: 20px;
            padding: 15px;
            background-color: #262626;
            border-radius: 5px;
            border: 1px solid #00ff00;
            font-size: 16px;
            font-family: 'Courier New', Courier, monospace;
            box-shadow: inset 0 0 10px rgba(0, 255, 0, 0.2);
        }

        .error {
            border-color: red;
            background-color: #4d0000;
            color: #ff9999;
        }

        /* Style for the canvas */
        #mapCanvas {
            width: 100%;
            max-width: 800px;
            height: 400px;
            background-color: #000000;
            border: 2px solid #00ff00;
            margin-top: 20px;
            cursor: grab;
        }

        .legend {
            color: #00ff00;
            font-family: 'Courier New', Courier, monospace;
            margin-top: 20px;
        }

        .legend div {
            display: inline-block;
            margin-right: 20px;
        }

        .legend span {
            display: inline-block;
            width: 10px;
            height: 10px;
            margin-right: 5px;
        }

        #tooltip {
            position: absolute;
            padding: 5px;
            background-color: #333;
            color: #fff;
            border-radius: 5px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
        }

    </style>
</head>
<body>

<div class="container">
    <h1>24/7 Conflict Ops-Artillery Elevation Calculator</h1>
   <a href="https://discord.com/grkfgh3EAh" rel="external">https://discord.com/grkfgh3EAh</a>

    <!-- Section 1: Calculate Barrel Elevation Based on Distance -->
    <div class="section">
        <h2>Calculate Barrel Elevation</h2>
        <label for="distance">Enter Distance (meters):</label>
        <input type="number" id="distance" placeholder="Enter distance in meters">

        <label for="muzzleVelocity">Muzzle Velocity (m/s):</label>
        <input type="number" id="muzzleVelocity" value="199.34" required>

        <label for="fireMode">Fire Mode:</label>
        <select id="fireMode">
            <option value="direct">Direct Fire</option>
            <option value="indirect">Indirect Fire</option>
        </select>

        <button onclick="calculateElevation()">Calculate Elevation</button>
        
        <div class="result" id="result"></div>
    </div>

    <!-- Section 2: Calculate Target Details with Elevation -->
    <div class="section">
        <h2>Calculate Target Details with Elevation</h2>
        
        <!-- Observer Details -->
        <h3>Observer Details (Optional)</h3>
        <label for="observer_x">Observer X Coordinate:</label>
        <input type="number" id="observer_x" placeholder="Enter observer X coordinate">
        
        <label for="observer_y">Observer Y Coordinate:</label>
        <input type="number" id="observer_y" placeholder="Enter observer Y coordinate">
        
        <label for="observer_bearing">Bearing from Observer (degrees):</label>
        <input type="number" id="observer_bearing" placeholder="Enter bearing from observer">
        
        <label for="observer_distance">Distance from Observer (meters):</label>
        <input type="number" id="observer_distance" placeholder="Enter distance from observer">
        
        <label for="observer_elevation">Observer Elevation (meters):</label>
        <input type="number" id="observer_elevation" placeholder="Enter observer elevation">

        <label for="elevation_difference">Elevation Difference to Target (meters):</label>
        <input type="number" id="elevation_difference" placeholder="Enter elevation difference from observer to target">

        <!-- Target Coordinates -->
        <h3>Target Coordinates (If Known)</h3>
        <label for="target_x">Target X Coordinate:</label>
        <input type="number" id="target_x" placeholder="Enter target X coordinate">
        
        <label for="target_y">Target Y Coordinate:</label>
        <input type="number" id="target_y" placeholder="Enter target Y coordinate">

        <label for="target_elevation">Target Elevation (meters):</label>
        <input type="number" id="target_elevation" placeholder="Enter target elevation">

        <!-- Your Coordinates -->
        <h3>Your Coordinates</h3>
        <label for="your_x">Your X Coordinate:</label>
        <input type="number" id="your_x" placeholder="Enter your X coordinate">
        
        <label for="your_y">Your Y Coordinate:</label>
        <input type="number" id="your_y" placeholder="Enter your Y coordinate">
        
        <label for="your_elevation">Your Elevation (meters):</label>
        <input type="number" id="your_elevation" placeholder="Enter your elevation">

        <button onclick="calculateTargetDetails()">Calculate Target Details</button>
        
        <div class="result" id="targetResult"></div>
    </div>

    <!-- Canvas for visualization -->
    <canvas id="mapCanvas"></canvas>

    <!-- Tooltip for showing coordinates -->
    <div id="tooltip"></div>

    <!-- Legend -->
    <div class="legend">
        <div><span style="background-color: cyan;"></span>Observer</div>
        <div><span style="background-color: red;"></span>Target</div>
        <div><span style="background-color: lime;"></span>Player</div>
    </div>

    <!-- Button to export the map as an image -->
    <button onclick="exportMap()">Export Map as Image</button>
</div>
<script>
let scale = 1;
let translatePos = { x: 0, y: 0 };
let isDragging = false;
let dragStart = { x: 0, y: 0 };
let tooltip = document.getElementById('tooltip');

// Function to calculate scaling factor for the map based on coordinates
function calculateScaleAndOffset(coordinates, canvasSize) {
    const xValues = coordinates.map(coord => coord.x);
    const yValues = coordinates.map(coord => coord.y);

    const minX = Math.min(...xValues);
    const maxX = Math.max(...xValues);
    const minY = Math.min(...yValues);
    const maxY = Math.max(...yValues);

    const padding = 20; // Safe margin in pixels
    const scaleX = (canvasSize.width - 2 * padding) / (maxX - minX); // Adjust scale to account for padding
    const scaleY = (canvasSize.height - 2 * padding) / (maxY - minY); // Adjust scale to account for padding
    const scale = Math.min(scaleX, scaleY);

    const offsetX = padding - minX * scale;
    const offsetY = padding - minY * scale;

    return { scale, offsetX, offsetY };
}

// Function to draw grid on the canvas
function drawGrid(ctx, canvasSize, scale, offsetX, offsetY) {
    const gridSize = 50; // Adjust grid size as needed
    ctx.strokeStyle = '#444'; // Grid color
    ctx.lineWidth = 1;

    // Draw vertical grid lines
    for (let x = 0; x <= canvasSize.width; x += gridSize * scale) {
        ctx.beginPath();
        ctx.moveTo(x + offsetX % (gridSize * scale), 0);
        ctx.lineTo(x + offsetX % (gridSize * scale), canvasSize.height);
        ctx.stroke();
    }

    // Draw horizontal grid lines
    for (let y = 0; y <= canvasSize.height; y += gridSize * scale) {
        ctx.beginPath();
        ctx.moveTo(0, y + offsetY % (gridSize * scale));
        ctx.lineTo(canvasSize.width, y + offsetY % (gridSize * scale));
        ctx.stroke();
    }
}

// Function to draw the map based on input coordinates
function drawMap(observer, target, player) {
    const canvas = document.getElementById('mapCanvas');
    const ctx = canvas.getContext('2d');

    // Calculate scale and offset
    const canvasSize = { width: canvas.width, height: canvas.height };
    const { scale, offsetX, offsetY } = calculateScaleAndOffset([observer, target, player], canvasSize);

    // Clear the canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Draw the grid
    drawGrid(ctx, canvasSize, scale, offsetX, offsetY);

    // Draw the observer
    ctx.fillStyle = 'cyan';
    ctx.beginPath();
    ctx.arc(observer.x * scale + offsetX, observer.y * scale + offsetY, 5, 0, 2 * Math.PI);
    ctx.fill();
    ctx.fillText('Observer', observer.x * scale + offsetX + 10, observer.y * scale + offsetY + 5);

    // Draw the target
    ctx.fillStyle = 'red';
    ctx.beginPath();
    ctx.arc(target.x * scale + offsetX, target.y * scale + offsetY, 5, 0, 2 * Math.PI);
    ctx.fill();
    ctx.fillText('Target', target.x * scale + offsetX + 10, target.y * scale + offsetY + 5);

    // Draw the player
    ctx.fillStyle = 'lime';
    ctx.beginPath();
    ctx.arc(player.x * scale + offsetX, player.y * scale + offsetY, 5, 0, 2 * Math.PI);
    ctx.fill();
    ctx.fillText('Player', player.x * scale + offsetX + 10, player.y * scale + offsetY + 5);

    // Draw lines between observer and target, and player and target
    ctx.strokeStyle = '#00ff00';
    ctx.lineWidth = 2;

    // Line from observer to target
    ctx.beginPath();
    ctx.moveTo(observer.x * scale + offsetX, observer.y * scale + offsetY);
    ctx.lineTo(target.x * scale + offsetX, target.y * scale + offsetY);
    ctx.stroke();

    // Line from player to target
    ctx.beginPath();
    ctx.moveTo(player.x * scale + offsetX, player.y * scale + offsetY);
    ctx.lineTo(target.x * scale + offsetX, target.y * scale + offsetY);
    ctx.stroke();

    // Display distance between points
    const distanceOT = Math.sqrt(Math.pow(target.x - observer.x, 2) + Math.pow(target.y - observer.y, 2)) * scale;
    const distancePT = Math.sqrt(Math.pow(target.x - player.x, 2) + Math.pow(target.y - player.y, 2)) * scale;

    ctx.fillStyle = '#ffffff';
    ctx.fillText(`${distanceOT.toFixed(2)} px`, (observer.x + target.x) * scale / 2 + offsetX, (observer.y + target.y) * scale / 2 + offsetY);
    ctx.fillText(`${distancePT.toFixed(2)} px`, (player.x + target.x) * scale / 2 + offsetX, (player.y + target.y) * scale / 2 + offsetY);
}

// Function to calculate target details and then draw the map
function calculateTargetDetails() {
    const observerX = parseFloat(document.getElementById("observer_x").value);
    const observerY = parseFloat(document.getElementById("observer_y").value);
    const targetX = parseFloat(document.getElementById("target_x").value);
    const targetY = parseFloat(document.getElementById("target_y").value);
    const playerX = parseFloat(document.getElementById("your_x").value);
    const playerY = parseFloat(document.getElementById("your_y").value);

    // Input validation
    if (isNaN(observerX) || isNaN(observerY) || isNaN(targetX) || isNaN(targetY) || isNaN(playerX) || isNaN(playerY)) {
        alert("Please enter valid numeric coordinates for all fields.");
        return;
    }

    const observer = { x: observerX, y: observerY };
    const target = { x: targetX, y: targetY };
    const player = { x: playerX, y: playerY };

    // Call the function to draw the map
    drawMap(observer, target, player);

    // Display some results (optional)
    const resultDiv = document.getElementById('targetResult');
    const distanceToTarget = Math.sqrt(Math.pow(targetX - playerX, 2) + Math.pow(targetY - playerY, 2));
    let bearingToTarget = Math.atan2(targetY - playerY, targetX - playerX) * (180 / Math.PI);

    // Adjust the bearing to be in the range 0° to 360°
    if (bearingToTarget < 0) {
        bearingToTarget += 360;
    }

    resultDiv.innerHTML = `<p>Distance to Target: ${distanceToTarget.toFixed(2)} meters</p>`;
    resultDiv.innerHTML += `<p>Bearing to Target: ${bearingToTarget.toFixed(2)}°</p>`;
}

// Zoom and Pan Functionality
document.getElementById('mapCanvas').addEventListener('wheel', (event) => {
    const scaleAmount = 1.1;
    if (event.deltaY < 0) {
        scale *= scaleAmount;
    } else {
        scale /= scaleAmount;
    }
    event.preventDefault(); // Prevent the page from scrolling
    calculateTargetDetails(); // Re-draw the map with the new scale
});

document.getElementById('mapCanvas').addEventListener('mousedown', (event) => {
    isDragging = true;
    dragStart.x = event.clientX - translatePos.x;
    dragStart.y = event.clientY - translatePos.y;
    document.getElementById('mapCanvas').style.cursor = 'grabbing';
});

document.getElementById('mapCanvas').addEventListener('mousemove', (event) => {
    if (isDragging) {
        translatePos.x = event.clientX - dragStart.x;
        translatePos.y = event.clientY - dragStart.y;
        calculateTargetDetails(); // Re-draw the map with the new position
    }
});

document.getElementById('mapCanvas').addEventListener('mouseup', () => {
    isDragging = false;
    document.getElementById('mapCanvas').style.cursor = 'grab';
});

// Function to show tooltip with coordinates on hover
document.getElementById('mapCanvas').addEventListener('mousemove', (event) => {
    const canvas = document.getElementById('mapCanvas');
    const rect = canvas.getBoundingClientRect();
    const x = (event.clientX - rect.left - translatePos.x) / scale;
    const y = (event.clientY - rect.top - translatePos.y) / scale;

    let hovered = false;

    // Check if hovering over the observer, target, or player
    const elements = [
        { label: 'Observer', x: observer.x, y: observer.y },
        { label: 'Target', x: target.x, y: target.y },
        { label: 'Player', x: player.x, y: player.y }
    ];

    for (const element of elements) {
        if (Math.abs(x - element.x) < 5 && Math.abs(y - element.y) < 5) {
            tooltip.style.left = event.clientX + 10 + 'px';
            tooltip.style.top = event.clientY + 10 + 'px';
            tooltip.innerHTML = `${element.label}: (${element.x.toFixed(2)}, ${element.y.toFixed(2)})`;
            tooltip.style.opacity = 1;
            hovered = true;
            break;
        }
    }

    if (!hovered) {
        tooltip.style.opacity = 0;
    }
});
</script>
</body>
</html>
